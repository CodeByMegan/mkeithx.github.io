---
title: The Zen of Python
description: Aphorisms that capture Python's philosophy
authors: mkeithx
date: 2025-03-01
slug: /updates/import-this
image: ./img/import-this.png
tags: [user_story, facts]
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import BrowserWindow from '@site/src/components/BrowserWindow';

**Python's Philosophy**

![import-this](./img/import-this.png)

In this post, we'll explore a set of principles, along with simple definitions and examples, that will help us write better code. 

**Let's go SAGO!** ðŸ˜†


{/* truncate */}

## Easter Egg

:::tip[Know this]

For starters, the Zen of Python is not just a set of guiding principles; it's also a fun [Easter egg](https://en.wikipedia.org/wiki/Easter_egg_(media)) hidden within Python itself. 

:::

To see the Zen of Python, follow these simple steps:

<Tabs>
  <TabItem value="pyscript" label="Python script" default>
     You need to be in a Python environment (like a Python shell or a script) to run this command.

     ```python
     import this
     ```
  </TabItem>
  <TabItem value="pyshell" label="Command line">

  This runs a Python command directly from the command line without entering the Python interactive shell.
    
    ```sh
    py -c 'import this'
    ```

  </TabItem>
</Tabs>

<pre>
The Zen of Python, by Tim Peters

Beautiful is better than ugly.
Explicit is better than implicit.
Simple is better than complex.
Complex is better than complicated.
Flat is better than nested.
Sparse is better than dense.
Readability counts.
Special cases aren't special enough to break the rules.
Although practicality beats purity.
Errors should never pass silently.
Unless explicitly silenced.
In the face of ambiguity, refuse the temptation to guess.
There should be one-- and preferably only one --obvious way to do it.
Although that way may not be obvious at first unless you're Dutch.
Now is better than never.
Although never is often better than *right* now.
If the implementation is hard to explain, it's a bad idea.
If the implementation is easy to explain, it may be a good idea.
Namespaces are one honking great idea -- let's do more of those!

</pre>

If you run into issues, it's likely that Python is not installed on your machine. [Download it here](https://www.python.org/downloads/).


---

## `import this`

### **_Beautiful is better than ugly_**

<details>
<summary>Clean, readable code is easier to understand and maintain.</summary>


* **Beauty**
    ```python
    def calculate_area(radius):
        return 3.14 * radius ** 2
    ```
* **Ugly**
    ```python
    def calcArea(r): 
        return 3.14*r*r
    ```
</details>

### **_Explicit is better than implicit_**

<details>
<summary>Make it obvious.</summary>

Avoid hidden meanings and ensure that the purpose of the code is obvious.

* **Explicit**
    ```python
    import datetime
    current_date = datetime.datetime.now()
    ```
* **Implicit**
    ```python
    from datetime import *
    current_date = now()
    ```

</details>


### **_Simple is better than complex_**

<details>
<summary>Simplicity leads to better code.</summary>

 Complex solutions should only be used when absolutely necessary.

* **Simple**
    ```python
    def add(a, b):
        return a + b
    ```
* **Complex**
    ```python
    def add(a, b):
        result = 0
        for i in range(a):
            result += 1
        for i in range(b):
            result += 1
        return result
    ```

</details>




### **_Complex is better than complicated_**

<details>
<summary>If complexity is unavoidable</summary>

It should be well-structured and understandable, not convoluted or confusing.


* **Complex**
    ```python
    def factorial(n):
        if n == 0:
            return 1
        else:
            return n * factorial(n-1)
    ```
* **Complicated**
    ```python
    def fact(n):
        return 1 if n == 0 else n * fact(n-1)
    ```

</details>


### **_Flat is better than nested_**

<details>
<summary>Avoid deep nesting of code structures. </summary>

Flat code is easier to read and manage.

* **Flat**
    ```python
    if condition1:
        do_something()
    elif condition2:
        do_something_else()
    ```
* **Nested**
    ```python
    if condition1:
        if condition2:
            do_something()
        else:
            do_something_else()
    ```
</details>


### **_Sparse is better than dense_**
<details>
<summary>Spread out code with appropriate spacing. </summary>

Dense code can be hard to read and understand.

* **Sparse**
    ```python
    def greet(name):
        print(f"Hello, {name}!")
    ```
* **Dense**
    ```python
    def greet(name):print(f"Hello, {name}!")
    ```


</details>


### **_Readability counts_**
<details>
<summary>Code is read more often than it is written. </summary>

Prioritize readability to make it easier for others (and yourself) to understand and maintain.

* **Readable**
    ```python
    def calculate_sum(numbers):
        total = 0
        for number in numbers:
            total += number
        return total
    ```
* **Less Readable**
    ```python
    def calc_sum(nums):
        return sum(nums)
    ```


</details>


### **_Special cases aren't special enough to break the rules_**

<details>
<summary>Consistency is key.</summary>

Stick to the rules and conventions of the language, even for special cases.

* **Following the rules**
    ```python
    def divide(a, b):
        if b == 0:
            raise ValueError("Cannot divide by zero")
        return a / b
    ```
* **Breaking the rules**
    ```python
    def divide(a, b):
        if b == 0:
            return None
        return a / b
    ```

</details>




### **_Although practicality beats purity_**

<details>
<summary>While following best practices is important ...</summary>

Practical solutions should take precedence when necessary.

* **Practical**
    ```python
    def read_file(file_path):
        try:
            with open(file_path, 'r') as file:
                return file.read()
        except FileNotFoundError:
            return "File not found"
    ```
* **Pure**
    ```python
    def read_file(file_path):
        with open(file_path, 'r') as file:
            return file.read()
    ```

</details>



### **_Errors should never pass silently_**
<details>
<summary>Errors should be handled properly. </summary>

Ignoring errors can lead to unexpected behavior and bugs.

* **Handling errors**
    ```python
    try:
        result = 10 / 0
    except ZeroDivisionError as e:
        print(f"Error: {e}")
    ```
* **Silently passing errors**
    ```python
    try:
        result = 10 / 0
    except ZeroDivisionError:
        pass
    ```

</details>


### **_Unless explicitly silenced_**
<details>
<summary>If an error must be ignored ...</summary>


it should be done explicitly and with good reason.

    ```python
    try:
        result = 10 / 0
    except ZeroDivisionError:
        result = None  # Explicitly handling the error
    ```
</details>



### **_In the face of ambiguity, refuse the temptation to guess_**

<details>
<summary>Do not make assumptions.</summary>


When code behavior is unclear, seek clarity and ensure the code's intent is explicit.

* **Seeking clarity**
    ```python
    def get_user_age(user):
        if 'age' in user:
            return user['age']
        else:
            raise KeyError("User age not found")
    ```
* **Guessing**
    ```python
    def get_user_age(user):
        return user.get('age', 0)  # Assuming age is 0 if not found
    ```
</details>



### **_There should be oneâ€”and preferably only oneâ€”obvious way to do it_**

<details>
<summary></summary>

Python emphasizes having a single, clear way to accomplish a task, reducing confusion and increasing consistency.

* **One obvious way**
    ```python
    def square(x):
        return x * x
    ```
* **Multiple ways**
    ```python
    def square(x):
        return x ** 2
    ```

</details>



### **_Although that way may not be obvious at first unless you're Dutch_**
<details>
<summary>Not immediately obvious</summary>

It suggests that the best way may not always be immediately apparent.

    ```python
    def reverse_string(s):
        return s[::-1]  # Using slicing to reverse a string
    ```

</details>



### **_Now is better than never_**
<details>
<summary>Just do it.</summary>


It's better to take action and write code now rather than procrastinate.

* **Taking action**
    ```python
    def start_project():
        print("Project started")

    start_project()
    ```
</details>



### **_Although never is often better than *right* now_**

<details>
<summary>Careful consideration</summary>

However, rushing to write code without proper thought can lead to poor quality. Balance urgency with careful consideration.

    ```python
    def start_project():
        # Plan and design before starting
        print("Project started after planning")

    start_project()
    ```


</details>



### **_If the implementation is hard to explain, it's a bad idea_**

<details>
<summary>Code should be simple enough to explain easily.</summary>


If it's too complex to explain, it likely needs to be simplified.

* **Easy to explain**
    ```python
    def add(a, b):
        return a + b
    ```
* **Hard to explain**
    ```python
    def add(a, b):
        result = 0
        for i in range(a):
            result += 1
        for i in range(b):
            result += 1
        return result
    ```

</details>

### **_If the implementation is easy to explain, it may be a good idea_**

<details>
<summary>The value of simplicity and clarity in coding.</summary>

When an implementation is easy to explain, it usually means that the code is straightforward, understandable, and maintainable. Simple and clear implementations are often the best solutions.

    ```python
    def factorial(n):
        if n == 0:
            return 1
        else:
    return n * factorial(n-1)
    ```


</details>



### **_Namespaces are one honking great ideaâ€”let's do more of those!_**

<details>
<summary>Using namespaces</summary>

Namespaces help organize code and avoid naming conflicts. Use them liberally to keep code clean and modular.

    ```python
    import math
    print(math.sqrt(16))  # Using the math namespace to access sqrt function
    ```

</details>



## References

* [Tim Peters](https://en.wikipedia.org/wiki/Tim_Peters_(software_engineer))
* [Guido van Rossum](https://en.wikipedia.org/wiki/Guido_van_Rossum)
* [PEP 20](https://peps.python.org/pep-0020/)
* [Easter egg](https://en.wikipedia.org/wiki/Easter_egg_(media))
* [BDFL](https://en.wikipedia.org/wiki/Benevolent_dictator_for_life)

---

**'Thanks'!**